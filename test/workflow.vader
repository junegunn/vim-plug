Execute (plug#end() before plug#begin() should fail):
  redir => out
  silent! AssertEqual 0, plug#end()
  redir END
  Assert stridx(out, 'plug#end() called without calling plug#begin() first') >= 0

Execute (plug#begin() without path argument):
  call plug#begin()
  AssertEqual split(&rtp, ',')[0].'/plugged', g:plug_home
  unlet g:plug_home

Execute (plug#begin() without path argument with empty &rtp):
  let save_rtp = &rtp
  set rtp=
  redir => out
  AssertEqual 0, plug#begin()
  redir END
  Assert stridx(out, 'Unable to determine plug home') >= 0
  let &rtp = save_rtp
  unlet save_rtp

Execute (Standard runtime path is not allowed):
  redir => out
  silent! AssertEqual 0, plug#begin(split(&rtp, ',')[0].'/plugin')
  redir END
  Log out
  Assert stridx(out, 'Invalid plug home') >= 0

Execute (plug#begin(path)):
  call plug#begin(g:temp_plugged.'/')
  Assert g:plug_home !~ '[/\\]$', 'Trailing / should be stripped from g:plug_home'

  AssertEqual 0, len(g:plugs)
  AssertEqual g:temp_plugged, g:plug_home
  AssertEqual g:base_rtp, &rtp

Execute (Subsequent plug#begin() calls will reuse g:plug_home):
  call plug#begin()
  AssertEqual g:temp_plugged, g:plug_home

Execute (Test Plug command):
^ Git repo with branch (DEPRECATED. USE BRANCH OPTION)
  Plug 'junegunn/seoul256.vim', { 'branch': 'yes-t_co' }
  AssertEqual 'file:///tmp/vim-plug-test/junegunn/seoul256.vim', g:plugs['seoul256.vim'].uri
  AssertEqual join([g:temp_plugged, 'seoul256.vim/'], '/'), g:plugs['seoul256.vim'].dir
  AssertEqual 'yes-t_co', g:plugs['seoul256.vim'].branch

  Plug 'junegunn/seoul256.vim', { 'branch': 'no-t_co' } " Using branch option
  AssertEqual 'no-t_co', g:plugs['seoul256.vim'].branch

^ Git repo with tag (DEPRECATED. USE TAG OPTION)
  redir => out
  silent Plug 'foo/bar.vim', ''
  redir END
  Assert out =~ 'Invalid argument for "tag" option of :Plug (expected: string)'
  Plug 'junegunn/goyo.vim', '1.5.2'
  AssertEqual 'file:///tmp/vim-plug-test/junegunn/goyo.vim', g:plugs['goyo.vim'].uri
  AssertEqual join([g:temp_plugged, 'goyo.vim/'], '/'), g:plugs['goyo.vim'].dir
  AssertEqual '1.5.2', g:plugs['goyo.vim'].tag

  redir => out
  silent Plug 'foo/bar.vim', {'tag': ''}
  redir END
  Assert out =~ 'Invalid argument for "tag" option of :Plug (expected: string)'
  Plug 'junegunn/goyo.vim', { 'tag': '1.5.3' } " Using tag option
  AssertEqual '1.5.3', g:plugs['goyo.vim'].tag

  " Git URI
  Plug 'file:///tmp/vim-plug-test/jg/vim-emoji'
  AssertEqual 'file:///tmp/vim-plug-test/jg/vim-emoji', g:plugs['vim-emoji'].uri
  AssertEqual '', g:plugs['vim-emoji'].branch
  AssertEqual join([g:temp_plugged, 'vim-emoji/'], '/'), g:plugs['vim-emoji'].dir

  " vim-scripts/
  Plug 'vim-scripts/beauty256'
  AssertEqual 'file:///tmp/vim-plug-test/vim-scripts/beauty256', g:plugs.beauty256.uri
  AssertEqual '', g:plugs.beauty256.branch

  AssertEqual 4, len(g:plugs)

  redir => out
  Plug 'beauty256'
  redir END
  Assert out =~ 'Invalid argument: beauty256'

Execute (Plug command with dictionary option):
  Log string(g:plugs)
  for opt in ['branch', 'tag', 'commit', 'rtp', 'dir', 'as']
    let opts = {}
    let opts[opt] = ''
    redir => out
    silent Plug 'foo/bar.vim', opts
    redir END
    Assert out =~ 'Invalid argument for "'.opt.'" option of :Plug (expected: string)'
  endfor
  for opt in ['on', 'for']
    let opts = {}
    let opts[opt] = ''
    redir => out
    silent Plug 'foo/bar.vim', opts
    redir END
    Assert out =~ 'Invalid argument for "'.opt.'" option of :Plug (expected: string or list)'
  endfor
  redir => out
  silent Plug 'foo/bar.vim', {'do': ''}
  redir END
  Assert out =~ 'Invalid argument for "do" option of :Plug (expected: string or funcref)'
  Plug 'junegunn/seoul256.vim', { 'branch': 'no-t_co', 'rtp': '././' }
  AssertEqual join([g:temp_plugged, 'seoul256.vim/'], '/'), g:plugs['seoul256.vim'].dir
  AssertEqual '././', g:plugs['seoul256.vim'].rtp

  Log string(g:plugs)
  AssertEqual 4, len(g:plugs)

Execute (PlugStatus before installation):
  PlugStatus
  AssertExpect 'Not found', 4
  q

Execute (PlugClean before installation):
  PlugClean
  AssertExpect 'Already clean', 1
  q

Execute (plug#end() updates &rtp):
  " Plug 'junegunn/goyo.vim', { 'tag': '1.5.3' }
  " Plug 'file:///tmp/vim-plug-test/jg/vim-emoji'
  " Plug 'beauty256'
  " Plug 'junegunn/seoul256.vim', { 'branch': 'no-t_co', 'rtp': '././' }
  call plug#end()
  Assert len(&rtp) > len(g:base_rtp)
  AssertEqual g:first_rtp, split(&rtp, ',')[0]
  AssertEqual g:last_rtp, split(&rtp, ',')[-1]

Execute (Yet, plugins are not available):
  Assert empty(globpath(&rtp, 'autoload/emoji.vim'))

Execute (PlugInstall):
  PlugInstall
  q

Execute (Plugin available after installation):
  Assert !empty(globpath(&rtp, 'autoload/emoji.vim'))

Execute (PlugClean after installation):
  PlugClean
  AssertExpect 'Already clean', 1
  q

Execute (PlugStatus after installation):
  PlugStatus
  Log getline(1, '$')
  AssertExpect 'OK', 4
  q

Execute (PlugUpdate - tagged plugin should not fail (#174)):
  PlugUpdate goyo.vim
  Log getline(1, '$')
  AssertExpect '^- goyo.vim', 1
  q

Execute (Change tag of goyo.vim):
  call plug#begin()
  Plug 'junegunn/goyo.vim', { 'tag': '9.9.9' }
  call plug#end()

Execute (PlugStatus):
  call PlugStatusSorted()

Expect:
      Invalid tag: 1.5.3 (expected: 9.9.9). Try PlugUpdate.
  Finished. 1 error(s).
  [=]
  x goyo.vim:

Execute (Remove tag of goyo.vim):
  call plug#begin()
  Plug 'junegunn/goyo.vim'
  call plug#end()

Execute (PlugStatus):
  call PlugStatusSorted()

Expect:
      Invalid branch: HEAD (expected: master). Try PlugUpdate.
  Finished. 1 error(s).
  [=]
  x goyo.vim:

Execute (PlugUpdate to set the right branch):
  PlugUpdate
  call PlugStatusSorted()

Expect:
  - goyo.vim: OK
  Finished. 0 error(s).
  [=]

Execute (Change branch of seoul256.vim):
  call plug#begin()
  Plug 'junegunn/seoul256.vim'
  Plug 'file:///tmp/vim-plug-test/jg/vim-emoji'
  call plug#end()

Execute (PlugStatus):
  call PlugStatusSorted()

Expect:
      Invalid branch: no-t_co (expected: master). Try PlugUpdate.
  - vim-emoji: OK
  Finished. 1 error(s).
  [==]
  x seoul256.vim:

Execute (PlugUpdate to switch branch, then PlugStatus):
  PlugUpdate
  call PlugStatusSorted()

Expect:
  - seoul256.vim: OK
  - vim-emoji: OK
  Finished. 0 error(s).
  [==]

Execute (Change tag of seoul256.vim):
  call plug#begin()
  Plug 'junegunn/seoul256.vim', { 'tag': 'no-such-tag' }
  call plug#end()
  call PlugStatusSorted()

Expect:
      Invalid tag: N/A (expected: no-such-tag). Try PlugUpdate.
  Finished. 1 error(s).
  [=]
  x seoul256.vim:

Execute (Change URI of seoul256.vim):
  call plug#begin()
  Plug 'junegunn.choi/seoul256.vim'
  Plug 'file:///tmp/vim-plug-test/jg/vim-emoji'
  call plug#end()

Execute (PlugStatus):
  call PlugStatusSorted()

Expect:
      Expected:    file:///tmp/vim-plug-test/junegunn.choi/seoul256.vim
      Invalid URI: file:///tmp/vim-plug-test/junegunn/seoul256.vim
      PlugClean required.
  - vim-emoji: OK
  Finished. 1 error(s).
  [==]
  x seoul256.vim:

Execute (Corrected the URI but ahead of upstream):
  call plug#begin()
  Plug 'junegunn/seoul256.vim'
  Plug 'file:///tmp/vim-plug-test/jg/vim-emoji'
  call plug#end()
  for _ in range(3)
    call system(printf('cd "%s" && git commit --allow-empty -m "dummy"', g:plugs['seoul256.vim'].dir))
  endfor
  call PlugStatusSorted()

Expect:
      Ahead of origin/master by 3 commit(s).
      Cannot update until local changes are pushed.
  - vim-emoji: OK
  Finished. 1 error(s).
  [==]
  x seoul256.vim:

# TODO: does not work due to inputsave()
# Do (PlugClean):
#   :PlugClean\<Enter>y\<Enter>
#   ggyG
#   q
#   PGdd

Execute (PlugClean! keeps seoul256.vim):
  PlugClean!
  " Two removed, emoji and seoul256 left
  AssertEqual 'Removed 2 directories.', getline(4)
  AssertExpect '^\~ ', 2
  AssertExpect 'Diverged', 0
  Assert !empty(globpath(&rtp, 'colors/seoul256.vim'))
  Assert !empty(globpath(&rtp, 'autoload/emoji.vim'))
  q

Execute (Make seoul256 to be diverged):
  call plug#begin()
  Plug 'junegunn/seoul256.vim'
  Plug 'file:///tmp/vim-plug-test/jg/vim-emoji'
  call plug#end()
  call system(printf(join([
    \ 'cd "%s"',
    \ 'git fetch --unshallow',
    \ 'git reset "@{u}~1"',
    \ 'git commit --allow-empty -m "diverged1"',
    \ 'git commit --allow-empty -m "diverged2"'], ' && '),
    \ g:plugs['seoul256.vim'].dir))
  Assert empty(v:shell_error), 'Got shell error: '.v:shell_error
  call PlugStatusSorted()

Expect:
      Backup local changes and run PlugClean and PlugUpdate to reinstall it.
      Diverged from origin/master (2 commit(s) ahead and 1 commit(s) behind!
  - vim-emoji: OK
  Finished. 1 error(s).
  [==]
  x seoul256.vim:

Execute (PlugClean! removes seoul256.vim):
  PlugClean!
  " One removed, emoji left
  AssertEqual 'Removed 1 directories.', getline(4)
  AssertExpect '^\~ ', 1
  AssertExpect 'Diverged', 1
  Assert empty(globpath(&rtp, 'colors/seoul256.vim'))
  Assert !empty(globpath(&rtp, 'autoload/emoji.vim'))
  q

Execute (Change GIT URI of vim-emoji):
  call plug#begin()
  Plug 'junegunn/seoul256.vim'
  Plug 'junegunn/vim-emoji'
  call plug#end()

Execute (PlugStatus):
  call PlugStatusSorted()

Expect:
      Expected:    file:///tmp/vim-plug-test/junegunn/vim-emoji
      Invalid URI: file:///tmp/vim-plug-test/jg/vim-emoji
      Not found. Try PlugInstall.
      PlugClean required.
  Finished. 2 error(s).
  [==]
  x seoul256.vim:
  x vim-emoji:

Execute (PlugClean! to remove vim-emoji):
  PlugClean!
  AssertExpect '^\~ ', 1
  AssertEqual 'Removed 1 directories.', getline(4)
  Assert empty(globpath(&rtp, 'colors/seoul256.vim')), 'seoul256.vim was removed'
  Assert empty(globpath(&rtp, 'autoload/emoji.vim')), 'emoji was removed'
  q

Execute (PlugUpdate to install both again):
  PlugUpdate
  AssertExpect '^- [^:]*:', 2
  Assert !empty(globpath(&rtp, 'colors/seoul256.vim')), 'seoul256.vim should be found'
  Assert !empty(globpath(&rtp, 'autoload/emoji.vim')), 'vim-emoji should be found'
  q

Execute (PlugUpdate only to find out plugins are up-to-date, D key to check):
  PlugUpdate
  AssertExpect 'Already up.to.date', 2, 'Expected 2 times "Already up-to-date", but got: '.string(getline(1, '$'))
  normal D
  AssertEqual '0 plugin(s) updated.', getline(1)
  q

Execute (PlugDiff - 'No updates.'):
  PlugDiff
  Log getline(1, '$')
  AssertEqual '0 plugin(s) updated.', getline(1)
  Assert empty(mapcheck('o'))
  Assert empty(mapcheck('X'))
  Assert empty(mapcheck("\<cr>"))
  q

Execute (New commits on remote, PlugUpdate, then PlugDiff):
  for repo in ['seoul256.vim', 'vim-emoji']
    for _ in range(2)
      call system(printf('cd /tmp/vim-plug-test/junegunn/%s && git commit --allow-empty -m "update"', repo))
    endfor
  endfor
  unlet repo
  PlugUpdate

  " Now we have updates
  normal D
  AssertEqual '2 plugin(s) updated.', getline(1)
  AssertThrows execute('/gpg')

  " Preview commit
  silent! wincmd P
  AssertEqual 0, &previewwindow

  " ]] motion
  execute 'normal ]]'
  let lnum = line('.')
  AssertEqual 3, col('.')

  " Open commit preview
  execute "normal j\<cr>"
  wincmd P
  AssertEqual 1, &previewwindow
  AssertEqual 'git', &filetype

  " Close preview window
  pclose

  " Open and go to preview window with a custom mapping
  nmap <buffer> <c-o> <plug>(plug-preview)<c-w>P
  execute "normal \<c-o>"
  AssertEqual 1, &previewwindow, 'Should be on preview window'
  normal q
  AssertEqual 0, &previewwindow, 'Should not be on preview window'

  " ]] motion
  execute 'normal $]]'
  Assert line('.') >= 4
    " 5+ for merge commit
  AssertEqual 3, col('.')

  " [[ motion
  execute 'normal 0[['
  AssertEqual lnum, line('.')
  unlet lnum
  AssertEqual 3, col('.')

  " X key to revert the update
  AssertExpect '^- ', 2
  execute "normal Xn\<cr>"
  AssertExpect '^- ', 2
  execute "normal Xy\<cr>"
  AssertExpect '^- ', 1

  " q will only close preview window
  normal q

  " We no longer have preview window
  silent! wincmd P
  AssertEqual 0, &previewwindow

  " And we're still on main vim-plug window
  AssertEqual 'vim-plug', &filetype
  normal q

  " q should not close preview window if it's already open
  pedit
  PlugDiff
  AssertExpect '^- ', 1
  execute "normal ]]j\<cr>"
  normal q

  silent! wincmd P
  AssertEqual 1, &previewwindow
  pclose

Execute (Test g:plug_pwindow):
  let g:plug_pwindow = 'below 5new'
  PlugDiff
  AssertExpect '^- ', 1
  execute "normal ]]jo"

  AssertEqual 0, &previewwindow
  AssertEqual 1, winnr()
  wincmd P
  AssertEqual 1, &previewwindow
  AssertEqual 2, winnr()
  AssertEqual 5, winheight('.')
  wincmd p

  " Close preview window
  normal q

  " Close main window
  normal q
  unlet g:plug_pwindow

Execute (#572 - Commit preview should work with non-POSIX-compliant &shell):
  " Invalid shell
  let shell = &shell
  set shell=shellfish

  try
    " Preview commit should still work
    PlugDiff
    execute "normal ]]jo"
    wincmd P
    Log getline(1, '$')
    Assert getline(1) =~ 'commit', 'Preview window is empty'
    AssertEqual 'shellfish', &shell
  finally
    " Restore &shell
    let &shell = shell
    unlet shell
    pclose
    q
  endtry

Execute (Reuse Plug window in another tab):
  let tabnr = tabpagenr()
  PlugDiff
  tab new new-tab
  set buftype=nofile
  PlugUpdate
  normal D
  AssertExpect '^- ', 1
  normal q
  AssertEqual tabnr, tabpagenr()
  normal! gt
  q
  unlet tabnr

Execute (contd. PlugDiff should not show inverted history):
  " Additional PlugUpdate to clear diff
  PlugUpdate
  PlugDiff
  Log getline(1, '$')

  " Checking out older revisions
  for repo in values(g:plugs)
    call system(printf('cd %s && git reset HEAD^ --hard', shellescape(repo.dir)))
  endfor
  unlet repo

  " PlugDiff should not report the changes i.e. git log --left-only
  PlugDiff
  Log getline(1, '$')
  AssertEqual '0 plugin(s) updated.', getline(1)
  q

**********************************************************************
~ PlugDiff to see the pending changes
**********************************************************************

Execute (PlugDiff):
  call plug#begin()
  call plug#end()
  PlugClean!

  call plug#begin()
  Plug 'file://'.expand('$PLUG_FIXTURES').'/xxx'
  Plug 'file://'.expand('$PLUG_FIXTURES').'/yyy'
  call plug#end()
  PlugInstall
  Log getline(1, '$')

  call system('cd "$PLUG_FIXTURES/xxx" && git commit --allow-empty -m update-xxx && git tag -f xxx')
  call system('cd "$PLUG_FIXTURES/yyy" && git tag -f yyy && git commit --allow-empty -m update-yyy && git tag -f zzz')

  let g:plugs.yyy.tag = 'yyy'
  PlugUpdate
  Log getline(1, '$')

  PlugDiff
  " 1 plugin(s) updated. 1 plugin(s) have pending updates.
  " [==]
  "
  " Last update:
  " ------------
  "
  " - xxx:
  "   166cfff (tag: xxx) update-xxx (1 second ago)
  "
  " Pending updates:
  " ----------------
  "
  " - yyy: (tag: yyy)
  "   c0a064b (tag: zzz) update-yyy (1 second ago)
  "
  Log getline(1, '$')
  AssertEqual 15, line('$')
  AssertEqual '1 plugin(s) updated. 1 plugin(s) have pending updates.', getline(1)
  AssertEqual '[==]', getline(2)
  AssertEqual '- yyy: (tag: yyy)', getline(13)
  Assert getline(8) =~ '(tag: xxx)'
  Assert getline(14) =~ '(tag: zzz)'
  Assert !empty(mapcheck('o'))
  Assert !empty(mapcheck('X'))
  Assert !empty(mapcheck("\<cr>"))
  q

Execute (Do not show diff for commits outside of rtp):
  call plug#begin()
  call plug#end()
  PlugClean!

  call plug#begin()
  Plug 'file://'.expand('$PLUG_FIXTURES').'/xxx'
  Plug 'file://'.expand('$PLUG_FIXTURES').'/yyy', { 'rtp': 'rtp' }
  call plug#end()
  PlugInstall
  Log getline(1, '$')

  call system('cd "$PLUG_FIXTURES/xxx" && git commit --allow-empty -m update-xxx && git tag -f xxx')
  call system('cd "$PLUG_FIXTURES/yyy" && git commit --allow-empty -m update-yyy && git tag -f yyy')

  let g:plugs.yyy.tag = 'yyy'
  PlugUpdate
  Log getline(1, '$')

  PlugDiff
  " 1 plugin(s) updated.
  " [==]
  "
  " Last update:
  " ------------
  "
  " - xxx:
  "   * 7faa9b2 update-xxx (0 seconds ago)
  "
  " Pending updates:
  " ----------------
  "
  " N/A
  "
  Log getline(1, '$')
  AssertEqual 14, line('$')
  AssertEqual '1 plugin(s) updated.', getline(1)
  AssertEqual '[==]', getline(2)
  AssertEqual 'Last update:', getline(4)
  AssertEqual '- xxx:', getline(7)
  Assert !empty(mapcheck('o'))
  Assert !empty(mapcheck('X'))
  Assert !empty(mapcheck("\<cr>"))
  q

**********************************************************************
~ On-demand loading / Partial installation/update ~
**********************************************************************

Execute (Trying to execute on-demand commands when plugin is not installed):
  call ReloadPlug()
  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'on': ['EasyAlign', 'LiveEasyAlign!'] }
  call plug#end()

  Assert exists(':EasyAlign')
  Assert exists(':LiveEasyAlign')
  AssertThrows EasyAlign
  AssertThrows LiveEasyAlign
  Assert !exists(':EasyAlign')
  Assert !exists(':LiveEasyAlign')

Execute (New set of plugins):
  call ReloadPlug()
  call plug#begin()
  Plug 'junegunn/vim-fnr'
  Plug 'junegunn/vim-pseudocl'
  Plug 'junegunn/vim-easy-align', { 'on': 'EasyAlign' }
  Plug 'junegunn/vim-redis',      { 'for': 'redis' }
  let user_autocmd = {}
  autocmd! User vim-fnr let user_autocmd.fnr = 1
  autocmd! User vim-easy-align let user_autocmd.easy_align = 1
  autocmd! User vim-redis let user_autocmd.redis = 1
  call plug#end()

Execute (Check commands):
  Assert !exists(':FNR'),          'FNR command should not be found'
  Assert !exists(':RedisExecute'), 'RedisExecute command should not be found'
  Assert empty(user_autocmd)

Execute (Partial PlugInstall):
  PlugInstall vim-fnr vim-easy-align
  AssertExpect 'vim-fnr', 1
  q

  PlugInstall vim-fnr vim-easy-align 1
  AssertExpect 'vim-fnr', 1
  AssertExpect 'vim-easy-align', 1
  AssertEqual g:first_rtp, split(&rtp, ',')[0]
  AssertEqual g:last_rtp, split(&rtp, ',')[-1]
  q

Given (Unaligned code):
  a=1
  aa=2

Execute (Check installed plugins):
  call EnsureLoaded()
  Assert exists(':FNR'),           'FNR command should be found'
  Assert !exists(':RedisExecute'), 'RedisExecute command still should not be found'

  Assert exists(':EasyAlign'), 'EasyAlign command should be found'
  %EasyAlign=

Expect (Aligned code):
  a  = 1
  aa = 2

Then (autocmd executed):
  Assert user_autocmd.easy_align
  AssertEqual 1, len(user_autocmd)

Given:
Execute (Partial PlugUpdate):
  PlugUpdate vim-redis
  q

Execute (On-demand loading based on filetypes):
  Assert !exists(':RedisExecute'), 'RedisExecute command still should not be found'
  set ft=redis
  Assert exists(':RedisExecute'), 'RedisExecute command is now found'
  Assert user_autocmd.redis
  AssertEqual 2, len(user_autocmd)

  autocmd! User
  unlet user_autocmd

**********************************************************************
~ Local (unmanaged) plugins
**********************************************************************

Execute (Add unmanaged plugin):
  let fzf = expand('$PLUG_FIXTURES/fzf')
  call RmRf(fzf)
  Log fzf

  call plug#begin()
  Plug fzf, { 'on': 'SomeCommand' }
  call plug#end()

  " Check uri field
  Assert !has_key(g:plugs.fzf, 'uri'), 'Should not have uri field'

  " Check dir field
  AssertEqual fzf.'/', g:plugs.fzf.dir

  " Trailing slashes and backslashes should be stripped
  for suffix in ['///', '/\/\/']
    call plug#begin()
    Plug fzf.suffix, { 'on': 'SomeCommand' }
    call plug#end()

    " Check dir field
    AssertEqual fzf.'/', g:plugs.fzf.dir
  endfor

Execute (Plug block for following tests):
  call plug#begin()
  Plug 'junegunn/vim-easy-align'
  Plug fzf, { 'on': 'SomeCommand' }
  call plug#end()
  " Remove plugins from previous tests
  PlugClean!
  q

Execute (PlugInstall will only install vim-easy-align):
  PlugInstall
  Log getline(1, '$')
  AssertExpect 'fzf', 0
  q

Execute (PlugUpdate will only update vim-easy-align):
  PlugUpdate
  Log getline(1, '$')
  AssertExpect 'fzf', 0
  q

Execute (PlugClean should not care about unmanaged plugins):
  PlugClean
  Log getline(1, '$')
  AssertExpect 'fzf', 0
  q

Execute (PlugStatus should point out that the plugin is missing):
  PlugStatus
  Log getline(1, '$')
  AssertExpect 'x fzf', 1
  AssertExpect 'Not found', 1
  q

Execute (Deploy unmanaged plugin):
  Assert !exists(':FZF'), ':FZF command should not exist'
  call RmRf(fzf)
  Log system(printf('cp -r "/tmp/vim-plug-test/fzf" "%s"', fzf))

Execute (PlugUpdate still should not care):
  PlugUpdate
  Log getline(1, '$')
  AssertExpect 'fzf', 0
  q

Execute (PlugStatus with no error):
  PlugStatus
  Log getline(1, '$')
  AssertExpect 'x fzf', 0
  AssertExpect 'Not found', 0
  q

Execute (Check &rtp after SomeCommand):
  Log &rtp
  Assert &rtp !~ 'fzf'
  silent! SomeCommand
  Assert &rtp =~ 'fzf'
  AssertEqual g:first_rtp, split(&rtp, ',')[0]
  AssertEqual g:last_rtp, split(&rtp, ',')[-1]

Execute (Common parent):
  call plug#begin()
  Plug 'junegunn/vim-pseudocl'
  Plug 'junegunn/vim-fnr'
  Plug 'junegunn/vim-oblique'
  call plug#end()

  PlugInstall
  Log getline(1, '$')
  AssertExpect! '[===]', 1
  q

  unlet fzf

**********************************************************************
~ Frozen plugins
**********************************************************************
- We've decided to install plugins that are frozen: see #113
Execute (Frozen plugin are not ~~installed nor~~ updated):
  " Remove plugins
  call plug#begin()
  call plug#end()
  PlugClean!
  q

  " vim-easy-align is not found, so it will be installed even though it's frozen
  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'frozen': 1 }
  call plug#end()
  PlugInstall
  AssertEqual 1, len(filter(getline(1, '$'), 'v:val =~ "vim-easy-align"'))
  q

  " Remove plugins again
  call plug#begin()
  call plug#end()
  PlugClean!
  q

  " PlugUpdate will do the same
  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'frozen': 1 }
  call plug#end()
  PlugInstall
  AssertEqual 1, len(filter(getline(1, '$'), 'v:val =~ "vim-easy-align"'))
  q

  " Since vim-easy-align already exists, PlugInstall or PlugUpdate will skip it
  redir => out
  silent PlugInstall
  redir END
  Assert out =~ 'No plugin to install'

  redir => out
  silent PlugUpdate
  redir END
  Assert out =~ 'No plugin to update'

Execute (But you can still install it if the name is given as the argument):
  PlugInstall vim-easy-align
  Log getline(1, '$')
  AssertEqual 1, len(filter(getline(1, '$'), 'v:val =~ "vim-easy-align"'))
  q

  PlugUpdate vim-easy-align
  Log getline(1, '$')
  AssertEqual 1, len(filter(getline(1, '$'), 'v:val =~ "vim-easy-align"'))
  q

**********************************************************************
~ Retry
**********************************************************************

Execute (Retry failed tasks):
  call plug#begin()
  Plug 'junegunn/vim-easy-align'
  Plug 'junegunn/aaaaaaaaaaaaaa'
  call plug#end()

  PlugInstall
  Log getline(1, '$')
  AssertExpect 'x aaa', 1
  AssertExpect '- vim-easy-align', 1
  normal R
  Log getline(1, '$')
  AssertExpect 'x aaa', 1
  AssertExpect '- vim-easy-align', 0
  AssertExpect! '[x]', 1
  q

  call plug#begin()
  Plug 'junegunn/vim-easy-align'
  Plug 'junegunn/aaaaaaaaaaaaaa'
  Plug 'junegunn/bbbbbbbbbbbbbb'
  Plug 'junegunn/cccccccccccccc'
  call plug#end()

  " Ruby installer
  PlugUpdate
  normal R
  AssertExpect '- vim-easy-align', 0
  AssertExpect! '[xxx]', 1
  q

  " Vim installer
  PlugUpdate 1
  normal R
  AssertExpect '- vim-easy-align', 0
  AssertExpect! '[xxx]', 1
  q

**********************************************************************
~ Post-update hook (`do` option)
**********************************************************************

Execute (Cleanup):
  call plug#begin()
  call plug#end()
  PlugClean!
  q

Execute (On install):
  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'do': 'touch installed' }
  Plug 'junegunn/vim-pseudocl'
  Plug 'junegunn/seoul256.vim'
  Plug 'junegunn/goyo.vim'
  Plug 'yous/subsubmodule'
  call plug#end()

  silent PlugInstall
  q

  Assert filereadable(g:plugs['vim-easy-align'].dir.'/installed'),
    \ 'vim-easy-align/installed should exist'
  Assert !filereadable(g:plugs['vim-pseudocl'].dir.'/installed'),
    \ 'vim-pseudocl/installed should not exist'
  AssertEqual ' ', system('cd '.g:plugs['subsubmodule'].dir.' && git submodule status')[0],
    \ 'subsubmodule/subsubmodule should be initialized'

Execute (On update):
  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'do': 'touch updated' }
  Plug 'junegunn/vim-pseudocl', { 'do': 'touch updated' }
  Plug 'junegunn/seoul256.vim'
  Plug 'junegunn/goyo.vim'
  Plug 'yous/subsubmodule'
  call plug#end()

  " New commits on remote
  call system('cd /tmp/vim-plug-test/junegunn/vim-pseudocl && git commit --allow-empty -m "update"')

  silent PlugUpdate
  Log getline(1, '$')
  q

  Assert !filereadable(g:plugs['vim-easy-align'].dir.'/updated'),
    \ 'vim-easy-align/updated should not exist'
  Assert filereadable(g:plugs['vim-pseudocl'].dir.'/updated'),
    \ 'vim-pseudocl/updated should exist'

Execute (When already installed):
  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'do': 'touch installed2' }
  Plug 'junegunn/vim-pseudocl', { 'commit': '7f8cd78' }
  Plug 'junegunn/seoul256.vim', { 'branch': 'no-t_co' }
  Plug 'junegunn/goyo.vim', { 'tag': '1.5.3' }
  Plug 'yous/subsubmodule'
  call plug#end()

  PlugInstall
  q
  Assert !filereadable(g:plugs['vim-easy-align'].dir.'/installed2'),
    \ 'vim-easy-align/installed2 should not exist'
  AssertNotEqual '7f8cd78cb1fe52185b98b16a3749811f0cc508af', GitCommit('vim-pseudocl')
  AssertNotEqual 'no-t_co', GitBranch('seoul256.vim')
  AssertNotEqual '1.5.3', GitTag('goyo.vim')

Execute (PlugInstall!):
  silent PlugInstall!
  q
  Assert filereadable(g:plugs['vim-easy-align'].dir.'/installed2'),
    \ 'vim-easy-align/installed2 should exist'
  AssertEqual '7f8cd78cb1fe52185b98b16a3749811f0cc508af', GitCommit('vim-pseudocl')
  AssertEqual 'no-t_co', GitBranch('seoul256.vim')
  AssertEqual '1.5.3', GitTag('goyo.vim')

Execute (When submodules are not initialized):
  call system(printf('cd %s && git submodule deinit subsubmodule', g:plugs['subsubmodule'].dir))

  silent PlugInstall!
  q

  AssertEqual ' ', system(printf('cd %s && git submodule status', g:plugs['subsubmodule'].dir))[0],
    \ 'subsubmodule/subsubmodule should be initialized'

Execute (When already updated):
  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'do': 'touch updated2' }
  Plug 'junegunn/vim-pseudocl', { 'commit': 'dd507ca' }
  Plug 'junegunn/seoul256.vim', { 'branch': 'master' }
  Plug 'junegunn/goyo.vim', { 'tag': '1.6.0' }
  Plug 'yous/subsubmodule'
  call plug#end()

  PlugUpdate
  q
  Assert !filereadable(g:plugs['vim-easy-align'].dir.'/updated2'),
    \ 'vim-easy-align/updated2 should not exist'
  AssertEqual 'dd507ca0d5f3fdf0d522558cc5ecffdabf824469', GitCommit('vim-pseudocl')
  AssertEqual 'master', GitBranch('seoul256.vim')
  AssertEqual '1.6.0', GitTag('goyo.vim')

Execute (PlugUpdate!):
  silent PlugUpdate!
  q
  Assert filereadable(g:plugs['vim-easy-align'].dir.'/updated2'),
    \ 'vim-easy-align/updated2 should exist'

Execute (When submodules are not initialized):
  call system(printf('cd %s && git submodule deinit subsubmodule', g:plugs['subsubmodule'].dir))

^ #481 submodule update should use standard shell
  let sh = &shell
  set sh=/bin/echo
  silent PlugUpdate!
  let &shell = sh
  unlet sh
  q
  AssertEqual ' ', system(printf('cd %s && git submodule status', g:plugs['subsubmodule'].dir))[0],
    \ 'subsubmodule/subsubmodule should be initialized'

Execute (Using Funcref):
  function! PlugUpdated(info)
    call system('touch '. a:info.name . a:info.status . a:info.force . len(a:info))
  endfunction

  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'do': function('PlugUpdated') }
  Plug 'junegunn/vim-pseudocl',   { 'do': function('PlugUpdated') }
  call plug#end()

  call system('cd /tmp/vim-plug-test/junegunn/vim-easy-align && git commit --allow-empty -m "update"')
  call system('cd '.g:plugs['vim-easy-align'].dir.' && git reset --hard HEAD^')
  call RmRf(g:plugs['vim-pseudocl'].dir)

  PlugUpdate
  Log getline(1, '$')
  q
  Assert filereadable(g:plugs['vim-easy-align'].dir.'/vim-easy-alignupdated03'),
    \ 'vim-easy-align/vim-easy-alignupdated03 should exist'
  Assert filereadable(g:plugs['vim-pseudocl'].dir.'/vim-pseudoclinstalled03'),
    \ 'vim-pseudocl/vim-pseudoclinstalled03 should exist'

  call RmRf(g:plugs['vim-pseudocl'].dir)
  PlugInstall!
  q
  Assert filereadable(g:plugs['vim-easy-align'].dir.'/vim-easy-alignunchanged13'),
    \ 'vim-easy-align/vim-easy-alignunchanged13 should exist'
  Assert filereadable(g:plugs['vim-pseudocl'].dir.'/vim-pseudoclinstalled13'),
    \ 'vim-pseudocl/vim-pseudoclinstalled13 should exist'

  call system('cd '.g:plugs['vim-easy-align'].dir.' && git reset --hard HEAD^')
  PlugUpdate!
  q
  Assert filereadable(g:plugs['vim-easy-align'].dir.'/vim-easy-alignupdated13'),
    \ 'vim-easy-align/vim-easy-alignupdated13 should exist'
  Assert filereadable(g:plugs['vim-pseudocl'].dir.'/vim-pseudoclunchanged13'),
    \ 'vim-pseudocl/vim-pseudoclunchanged13 should exist'

Execute (Post-update hook output; success and failure):
  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'do': 'xxx-non-existent-command-xxx' }
  Plug 'junegunn/vim-pseudocl',   { 'do': 'true' }
  call plug#end()

  silent PlugInstall! 1
  AssertEqual '- Post-update hook for vim-pseudocl ... OK', getline(5)
  AssertEqual 'x Post-update hook for vim-easy-align ... Exit status: 127', getline(6)
  q

Execute (Post-update hook output; invalid type or funcref):
  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'do': ':echo 1' }
  Plug 'junegunn/vim-pseudocl',   { 'do': function('call') }
  call plug#end()
  let g:plugs['vim-easy-align'].do = 1

  silent PlugInstall! 1
  AssertEqual 'x Post-update hook for vim-pseudocl ... Vim(call):E119: Not enough arguments for function: call', getline(5)
  AssertEqual 'x Post-update hook for vim-easy-align ... Invalid hook type', getline(6)
  q

Execute (Should not run when failed to update):
  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'do': 'touch failed'     }
  Plug 'junegunn/vim-pseudocl',   { 'do': 'touch not-failed' }
  call plug#end()

  " Invalid remote URL
  call system(printf('cd %s && git remote set-url origin xxx', g:plugs['vim-easy-align'].dir))

  " New commits on remote
  call system('cd /tmp/vim-plug-test/junegunn/vim-easy-align && git commit --allow-empty -m "update"')
  call system('cd /tmp/vim-plug-test/junegunn/vim-pseudocl && git commit --allow-empty -m "update"')

  silent PlugUpdate
  Log getline(1, '$')
  q

  Assert !filereadable(g:plugs['vim-easy-align'].dir.'/failed'),
    \ 'vim-easy-align/failed should not exist'
  Assert filereadable(g:plugs['vim-pseudocl'].dir.'/not-failed'),
    \ 'vim-pseudocl/not-failed should exist'

Execute (Vim command with : prefix):
  call plug#begin()
  Plug 'junegunn/vim-pseudocl', { 'do': ':call setline(2, 12345)' }
  call plug#end()

  PlugInstall!
  Log getline(1, '$')
  AssertEqual '12345', getline(2)
  q

Execute (Vim command with : prefix closing the window):
  call plug#begin()
  Plug 'junegunn/vim-pseudocl', { 'do': ':close' }
  call plug#end()

  redir => out
  PlugInstall!
  redir END
  Assert out =~ 'vim-plug was terminated'
  Assert out =~ 'of vim-pseudocl'

Execute (Invalid vim command in post-update hook):
  call plug#begin()
  Plug 'junegunn/vim-pseudocl', { 'do': ':nosuchcommand' }
  call plug#end()

  PlugInstall!
  Log getline(1, '$')
  AssertExpect! 'x Post-update hook for vim-pseudocl ... Vim:E492: Not an editor command: nosuchcommand', 1
  q

**********************************************************************
~ Overriding `dir`
**********************************************************************

Execute (Using custom dir):
  call plug#begin()
  Plug 'junegunn/vim-easy-align'
  call plug#end()
  Assert isdirectory(g:plugs['vim-easy-align'].dir)

  call RmRf('/tmp/vim-plug-test/easy-align')
  call plug#begin()
  Plug 'junegunn/vim-easy-align', { 'dir': '/tmp/vim-plug-test/easy-align' }
  call plug#end()
  AssertEqual '/tmp/vim-plug-test/easy-align/', g:plugs['vim-easy-align'].dir

  PlugClean!
  Assert !isdirectory(g:plugs['vim-easy-align'].dir)
  q

  PlugInstall
  q
  Assert isdirectory(g:plugs['vim-easy-align'].dir)

**********************************************************************
~ On-demand loading load order
**********************************************************************
Before (Clear global vars):
  let g:xxx = []
  set rtp-=$PLUG_FIXTURES/xxx/
  set rtp-=$PLUG_FIXTURES/xxx/after

Execute (Immediate loading):
  call ReloadPlug()
  call plug#begin()
  Plug '$PLUG_FIXTURES/xxx'
  call plug#end()

  " FIXME:
  " Different result when Vader is run from commandline with `-c` option
  Log g:xxx
  if has('vim_starting')
    AssertEqual ['xxx/ftdetect', 'xxx/after/ftdetect'], g:xxx
  else
    AssertEqual ['xxx/plugin', 'xxx/after/plugin', 'xxx/ftdetect', 'xxx/after/ftdetect'], g:xxx
  endif

Execute (Command-based on-demand loading):
  call ReloadPlug()
  call plug#begin()
  Plug '$PLUG_FIXTURES/xxx', { 'on': 'XXX' }
  call plug#end()

  AssertEqual [], g:xxx

  silent! XXX
  AssertEqual ['xxx/ftdetect', 'xxx/after/ftdetect', 'xxx/plugin', 'xxx/after/plugin'], g:xxx

  setf xxx
  AssertEqual ['xxx/ftdetect', 'xxx/after/ftdetect', 'xxx/plugin', 'xxx/after/plugin', 'xxx/ftplugin', 'xxx/after/ftplugin', 'xxx/indent', 'xxx/after/indent', 'xxx/syntax', 'xxx/after/syntax'], g:xxx

Execute (Filetype-based on-demand loading):
  call ReloadPlug()
  call plug#begin()
  Plug '$PLUG_FIXTURES/xxx', { 'for': 'xxx' }
  Plug '$PLUG_FIXTURES/yyy', { 'for': 'yyy' }
  call plug#end()

  AssertEqual ['xxx/ftdetect', 'xxx/after/ftdetect'], g:xxx

  setf xxx
  AssertEqual ['xxx/ftdetect', 'xxx/after/ftdetect', 'xxx/plugin', 'xxx/after/plugin', 'xxx/syntax', 'xxx/after/syntax', 'xxx/ftplugin', 'xxx/after/ftplugin', 'xxx/indent', 'xxx/after/indent'], g:xxx

  " syntax/xxx.vim and after/syntax/xxx.vim should not be loaded (#410)
  setf yyy
  AssertEqual ['yyy/ftdetect', 'yyy/after/ftdetect', 'yyy/plugin', 'yyy/after/plugin'], g:yyy

Before:

**********************************************************************
~ plug#helptags()
**********************************************************************

Execute (plug#helptags):
  call plug#begin()
  Plug '$PLUG_FIXTURES/xxx'
  Plug '$PLUG_FIXTURES/yyy', { 'rtp': 'rtp' }
  call plug#end()
  silent! call delete(expand('$PLUG_FIXTURES/xxx/doc/tags'))
  silent! call delete(expand('$PLUG_FIXTURES/yyy/rtp/doc/tags'))
  Assert !filereadable(expand('$PLUG_FIXTURES/xxx/doc/tags'))
  Assert !filereadable(expand('$PLUG_FIXTURES/yyy/rtp/doc/tags'))
  AssertEqual 1, plug#helptags()
  Assert filereadable(expand('$PLUG_FIXTURES/xxx/doc/tags'))
  Assert filereadable(expand('$PLUG_FIXTURES/yyy/rtp/doc/tags'))

**********************************************************************
~ Manual loading
**********************************************************************

Execute (plug#load - invalid arguments):
  call ResetPlug()
  call plug#begin()
  Plug '$PLUG_FIXTURES/xxx', { 'for': 'xxx' }
  Plug '$PLUG_FIXTURES/yyy', { 'for': 'yyy' }
  call plug#end()
  AssertEqual 0, plug#load()
  AssertEqual 0, plug#load('non-existent-plugin')
  AssertEqual 0, plug#load('non-existent-plugin', 'another-non-existent-plugin')
  AssertEqual 1, plug#load('xxx')
  AssertEqual 0, plug#load('xxx', 'non-existent-plugin')
  AssertEqual 0, plug#load('non-existent-plugin', 'xxx')

Execute (plug#load - list argument (#638)):
  redir => out
  call plug#load(keys(g:plugs))
  redir END
  AssertEqual '', out

Execute (on: []):
  call plug#begin()
  Plug 'junegunn/rust.vim', { 'on': [] }
  call plug#end()
  PlugInstall
  q

Execute (PlugStatus reports (not loaded)):
  PlugStatus
  AssertExpect 'not loaded', 1
  q

Execute (plug#load to load it):
  tabnew test.rs
  " Vader will switch tab to [Vader-workbench] after Log
  " Log &filetype
  AssertEqual 1, plug#load('rust.vim')
  AssertEqual 'rust', &filetype
  q

Execute (PlugStatus should not contain (not loaded)):
  PlugStatus
  AssertExpect 'not loaded', 0
  q

Execute (Load plugin from PlugStatus screen with L key in normal mode):
  call ResetPlug()
  unlet! g:yyy
  call plug#begin()
  Plug '$PLUG_FIXTURES/yyy', { 'on': [] }
  call plug#end()

  PlugStatus
  AssertExpect 'not loaded', 1
  Assert !exists('g:yyy'), 'yyy not loaded'
  /not loaded
  normal L
  AssertExpect 'not loaded', 0
  Assert exists('g:yyy'), 'yyy loaded'
  q

Execute (Load plugin from PlugStatus screen with L key in visual mode):
  call plug#begin()
  Plug '$PLUG_FIXTURES/z1', { 'on':  [] }
  Plug '$PLUG_FIXTURES/z2', { 'for': [] }
  call plug#end()

  PlugStatus
  AssertExpect 'not loaded', 2
  Assert !exists('g:z1'), 'z1 not loaded'
  Assert !exists('g:z2'), 'z2 not loaded'
  normal ggVGL
  AssertExpect 'not loaded', 0
  Assert exists('g:z1'), 'z1 loaded'
  Assert exists('g:z2'), 'z2 loaded'
  q

**********************************************************************
~ g:plug_window
**********************************************************************
Execute (Open plug window in a new tab):
  " Without g:plug_window, plug window is open on the left split
  let tabnr = tabpagenr()
  PlugStatus
  AssertEqual tabnr, tabpagenr()
  AssertEqual 1, winnr()

  " PlugStatus again inside the window should not change the view
  normal S
  AssertEqual tabnr, tabpagenr()
  AssertEqual 1, winnr()
  q

  " Define g:plug_window so that plug window is open in a new tab
  let g:plug_window = 'tabnew'
  PlugStatus
  AssertNotEqual tabnr, tabpagenr()

  " PlugStatus again inside the window should not change the view
  let tabnr = tabpagenr()
  normal S
  AssertEqual tabnr, tabpagenr()
  q
  unlet g:plug_window tabnr

**********************************************************************
~ g:plug_url_format
**********************************************************************
Execute (Using g:plug_url_format):
  let prev_plug_url_format = g:plug_url_format
  call plug#begin()
  let g:plug_url_format = 'git@bitbucket.org:%s.git'
  Plug 'junegunn/seoul256.vim'
  let g:plug_url_format = 'git@bitsocket.org:%s.git'
  Plug 'vim-scripts/beauty256'
  AssertEqual 'git@bitbucket.org:junegunn/seoul256.vim.git', g:plugs['seoul256.vim'].uri
  AssertEqual 'git@bitsocket.org:vim-scripts/beauty256.git', g:plugs['beauty256'].uri
  let g:plug_url_format = prev_plug_url_format

**********************************************************************
~ U
**********************************************************************
Execute (Plug block):
  call plug#begin()
  Plug 'junegunn/vim-easy-align'
  Plug 'junegunn/vim-emoji'
  call plug#end()

Execute (Update plugin with U key in normal mode):
  PlugStatus
  /emoji
  normal U
  Log getline(1, '$')
  AssertExpect 'Updated', 1
  AssertExpect 'vim-emoji', 1
  AssertExpect 'vim-easy-align', 0
  AssertExpect! '[=]', 1

  " From PlugInstall screen
  PlugInstall
  /easy-align
  normal U
  AssertExpect 'Updated', 1
  AssertExpect 'vim-emoji', 0
  AssertExpect 'vim-easy-align', 1
  AssertExpect! '[=]', 1
  q

Execute (Update plugins with U key in visual mode):
  silent! call RmRf(g:plugs['vim-easy-align'].dir)

  PlugStatus
  normal VGU
  Log getline(1, '$')
  AssertExpect 'Updated', 1
  AssertExpect 'vim-emoji', 1
  AssertExpect 'vim-easy-align', 1
  AssertExpect! '[==]', 1

  " From PlugUpdate screen
  normal VGU
  Log getline(1, '$')
  AssertExpect 'Updated', 1
  AssertExpect 'vim-emoji', 1
  AssertExpect 'vim-easy-align', 1
  AssertExpect! '[==]', 1
  q

**********************************************************************
Execute (plug#begin should expand env vars):
  AssertNotEqual '$HOME/.emacs/plugged', expand('$HOME/.emacs/plugged')
  call plug#begin('$HOME/.emacs/plugged')
  AssertEqual expand('$HOME/.emacs/plugged'), g:plug_home

**********************************************************************
Execute (Plug directory with comma):
  call plug#begin(g:temp_plugged . '/p,l,u,g,g,e,d')
  Plug 'junegunn/vim-emoji'
  call plug#end()
  Log &rtp

  PlugInstall
  q
  let found = filter(split(globpath(&rtp, 'README.md'), '\n'), 'v:val =~ ","')
  Log found
  AssertEqual 1, len(found)
  unlet found

**********************************************************************
Execute (Strict load order):
  let g:total_order = []
  call ReloadPlug()
  call plug#begin()
  Plug '$PLUG_FIXTURES/xxx'
  Plug '$PLUG_FIXTURES/yyy', { 'for': ['xxx'] }
  call plug#end()
  call EnsureLoaded()
  setf xxx
  Log 'Case 1: ' . &rtp
  AssertEqual ['yyy/ftdetect', 'yyy/after/ftdetect', 'xxx/ftdetect', 'xxx/after/ftdetect'], g:total_order[0:3]
  Assert index(g:total_order, 'xxx/plugin') < index(g:total_order, 'yyy/plugin')
  Assert index(g:total_order, 'xxx/after/plugin') < index(g:total_order, 'yyy/after/plugin')
  let len = len(split(&rtp, ','))

  let g:total_order = []
  call ReloadPlug()
  call plug#begin()
  Plug '$PLUG_FIXTURES/xxx', { 'for': ['xxx'] }
  Plug '$PLUG_FIXTURES/yyy'
  call plug#end()
  call EnsureLoaded()
  set rtp^=manually-prepended
  set rtp+=manually-appended
  setf xxx
  Log 'Case 2: ' . &rtp
  AssertEqual 'manually-prepended', split(&rtp, ',')[3]
  AssertEqual 'manually-appended',  split(&rtp, ',')[-4]
  AssertEqual ['xxx/ftdetect', 'xxx/after/ftdetect', 'yyy/ftdetect', 'yyy/after/ftdetect'], g:total_order[0:3]
  Assert index(g:total_order, 'yyy/plugin') < index(g:total_order, 'xxx/plugin')
  Assert index(g:total_order, 'yyy/after/plugin') < index(g:total_order, 'xxx/after/plugin')
  AssertEqual len + 2, len(split(&rtp, ','))

  let g:total_order = []
  call ReloadPlug()
  set rtp^=manually-prepended
  set rtp+=manually-appended
  call plug#begin()
  Plug '$PLUG_FIXTURES/xxx', { 'for': ['xxx'] }
  Plug '$PLUG_FIXTURES/yyy', { 'for': ['xxx'] }
  call plug#end()
  call EnsureLoaded()
  setf xxx
  Log 'Case 3: ' . &rtp
  AssertEqual ['xxx/ftdetect', 'xxx/after/ftdetect', 'yyy/ftdetect', 'yyy/after/ftdetect'], g:total_order[0:3]
  Assert index(g:total_order, 'xxx/plugin') < index(g:total_order, 'yyy/plugin')
  Assert index(g:total_order, 'xxx/after/plugin') < index(g:total_order, 'yyy/after/plugin')
  AssertEqual len + 2, len(split(&rtp, ','))

**********************************************************************
Execute (PlugClean should not try to remove unmanaged plugins inside g:plug_home):
  call plug#begin('$PLUG_FIXTURES')
  Plug '$PLUG_FIXTURES/ftplugin-msg', { 'for': [] }
  Plug '$PLUG_FIXTURES/fzf'
  Plug '$PLUG_FIXTURES/xxx'
  Plug '$PLUG_FIXTURES/yyy'
  Plug '$PLUG_FIXTURES/cant-delete'
  call plug#end()

  " Remove z1, z2
  PlugClean!
  AssertExpect '^\~ ', 2
  AssertExpect 'Already clean', 0

  PlugClean!
  AssertExpect '^\~ ', 0
  AssertExpect 'Already clean', 1
  q

**********************************************************************
Execute (PlugSnapshot / #154 issues with paths containing spaces):
  let $TMPDIR = '/tmp'
  call plug#begin('$TMPDIR/plug with spaces')
  Plug 'junegunn/vim-easy-align'
  Plug 'junegunn/seoul256.vim'
  call plug#end()

  PlugClean!
  PlugInstall
  call plug#load('vim-easy-align') " Should properly handle paths with spaces
  PlugSnapshot
  AssertEqual '" Generated by vim-plug', getline(1)
  AssertEqual 0, stridx(getline(6), "silent! let g:plugs['seoul256.vim'].commit = '")
  AssertEqual 0, stridx(getline(7), "silent! let g:plugs['vim-easy-align'].commit = '")
  AssertEqual 'vim', &filetype

  call delete(g:plug_home.'/snapshot.vim')
  execute 'PlugSnapshot' escape(g:plug_home.'/snapshot.vim', ' ')
  AssertEqual 'vim', &filetype
  AssertEqual 'snapshot.vim', fnamemodify(expand('%'), ':t')
  q

Execute(PlugSnapshot! to overwrite existing file):
  call writefile(['foobar'], g:plug_home.'/snapshot.vim')
  AssertEqual 'foobar', readfile(g:plug_home.'/snapshot.vim')[0]
  execute 'PlugSnapshot!' escape(g:plug_home.'/snapshot.vim', ' ')
  AssertEqual '" Generated by vim-plug', readfile(g:plug_home.'/snapshot.vim')[0]
  q

**********************************************************************
Execute (#221 Shallow-clone and tag option):
  call plug#begin(g:temp_plugged)
  Plug 'junegunn/goyo.vim'
  call plug#end()
  PlugInstall

  execute 'cd' g:plugs['goyo.vim'].dir
  Assert len(split(system('git log --oneline'), '\n')) == 1
  Assert filereadable('.git/shallow')

  Plug 'junegunn/goyo.vim', { 'tag': '1.5.3' }
  PlugUpdate
  q

  Assert len(split(system('git log --oneline'), '\n')) > 1
  Assert system('git describe --tag') =~ '^1.5.3'
  Assert !filereadable('.git/shallow')
  cd -

Execute (#221 Shallow-clone disabled by g:plug_shallow = 0):
  call plug#begin(g:temp_plugged)
  call plug#end()
  PlugClean!

  let g:plug_shallow = 0
  call plug#begin(g:temp_plugged)
  Plug 'junegunn/goyo.vim'
  call plug#end()
  PlugInstall
  q

  execute 'cd' g:plugs['goyo.vim'].dir
  Assert len(split(system('git log --oneline'), '\n')) > 1, 'not shallow'
  Assert !filereadable('.git/shallow'), 'not shallow'
  cd -
  unlet g:plug_shallow

Execute (#221 Shallow-clone disabled by tag):
  call plug#begin(g:temp_plugged)
  call plug#end()
  PlugClean!

  call plug#begin(g:temp_plugged)
  Plug 'junegunn/goyo.vim', { 'tag': '1.5.3' }
  call plug#end()
  Assert !isdirectory(g:plugs['goyo.vim'].dir)
  PlugInstall
  Assert isdirectory(g:plugs['goyo.vim'].dir)
  q

  execute 'cd' g:plugs['goyo.vim'].dir
  Assert system('git describe --tag') =~ '^1.5.3'
  Assert len(split(system('git log --oneline'), '\n')) > 1
  Assert !filereadable('.git/shallow')
  cd -

Execute (Commit hash support):
  " Get goyo back to master
  call plug#begin(g:temp_plugged)
  Plug 'junegunn/goyo.vim'
  call plug#end()
  PlugUpdate

  call plug#begin(g:temp_plugged)
  Plug 'junegunn/goyo.vim',  { 'commit': 'ffffffff' }
  Plug 'junegunn/vim-emoji', { 'commit': '9db7fcfee0d90dafdbcb7a32090c0a9085eb054a' }
  call plug#end()
  PlugUpdate
  Log getline(1, '$')
  AssertEqual 'x goyo.vim:', getline(5)
  AssertEqual '    fatal: invalid reference: ffffffff', getline(6)
  AssertEqual 0, stridx(getline(7), '- vim-emoji: HEAD is now at 9db7fcf')

  let hash = system(printf('cd %s && git rev-parse HEAD', g:plugs['vim-emoji'].dir))[:-2]
  AssertEqual '9db7fcfee0d90dafdbcb7a32090c0a9085eb054a', hash

  " Validate error formatting
  PlugStatus
  Log getline(1, '$')
  AssertEqual ['Finished. 1 error(s).',
              \'[==]',
              \'',
              \'x goyo.vim:'], getline(1, 4)
  Assert getline(5) =~ '    Invalid HEAD (expected: fffffff, actual: [0-9a-f]\{7})'
  AssertEqual ['    PlugUpdate required.',
              \'- vim-emoji: OK'], getline(6, '$')

  " PlugDiff should show pending updates for vim-emoji
  PlugDiff
  Log getline(1, '$')
  AssertEqual '0 plugin(s) updated. 1 plugin(s) have pending updates.', getline(1)
  Assert !empty(mapcheck('o'))
  Assert empty(mapcheck('X'))
  Assert !empty(mapcheck("\<cr>"))

  " Nor in PlugSnapshot output
  PlugSnapshot
  Log getline(1, '$')
  AssertEqual 8, line('$')
  q

Execute (Commit hash support - cleared):
  call plug#begin(g:temp_plugged)
  Plug 'junegunn/goyo.vim'
  Plug 'junegunn/vim-emoji'
  call plug#end()

  PlugInstall
  let hash = system(printf('cd %s && git rev-parse HEAD', g:plugs['vim-emoji'].dir))[:-2]
  AssertEqual '9db7fcfee0d90dafdbcb7a32090c0a9085eb054a', hash

  PlugUpdate
  let hash = system(printf('cd %s && git rev-parse HEAD', g:plugs['vim-emoji'].dir))[:-2]
  AssertNotEqual '9db7fcfee0d90dafdbcb7a32090c0a9085eb054a', hash
  q

Execute (#371 - 'as' option):
  call plug#begin()
  Plug 'jg/goyo.vim'
  Plug 'junegunn/goyo.vim', {'as': 'yogo'}
  call plug#end()
  AssertEqual ['goyo.vim', 'yogo'], sort(keys(g:plugs))
  Log g:plugs
  Assert g:plugs.yogo.dir =~# '/yogo/$'

  call plug#begin()
  Plug 'junegunn/goyo.vim', {'as': 'yogo', 'dir': '/tmp/vim-plug-test/gogo'}
  call plug#end()
  AssertEqual ['yogo'], sort(keys(g:plugs))
  AssertEqual '/tmp/vim-plug-test/gogo/', g:plugs.yogo.dir

Execute (#427 - Tag option with wildcard (requires git 1.9.2 or above)):
  if str2nr(split(split(system('git --version'))[-1], '\.')[0]) < 2
    Log 'tag with wildcard requires git 1.9.2 or above'
  else
    call plug#begin()
    Plug 'junegunn/vim-easy-align', { 'tag': '2.9.*' }
    call plug#end()
    PlugInstall!
    Log getline(1, '$')
    AssertExpect! '- Latest tag for 2.9.* -> 2.9.7 (vim-easy-align)', 1
    q
    AssertEqual '2.9.7', GitTag('vim-easy-align')
  endif

Execute (#530 - Comparison of compatible git URIs):
  " .git suffix
  Assert CompareURI('https://github.com/junegunn/vim-plug.git', 'https://github.com/junegunn/vim-plug')

  " user@
  Assert CompareURI('https://github.com/junegunn/vim-plug.git', 'https://user@github.com/junegunn/vim-plug.git')

  " git::@
  Assert CompareURI('https://github.com/junegunn/vim-plug.git', 'https://git::@github.com/junegunn/vim-plug.git')

  " https and ssh
  Assert CompareURI('https://github.com/junegunn/vim-plug.git', 'git@github.com:junegunn/vim-plug.git')

  " file://
  Assert CompareURI('file:///tmp/vim-plug', '/tmp/vim-plug')
  Assert CompareURI('file:///tmp/vim-plug', '/tmp/vim-plug/')

Execute (#530 - Comparison of incompatible git URIs):
  " Different hostname
  Assert !CompareURI('https://github.com/junegunn/vim-plug.git', 'https://bitbucket.com/junegunn/vim-plug.git')

  " Different repository
  Assert !CompareURI('https://github.com/junegunn/vim-plug.git', 'https://github.com/junegunn/emacs-plug.git')

  " Different port
  Assert !CompareURI('https://github.com/junegunn/vim-plug.git', 'https://github.com:12345/junegunn/vim-plug.git')

Execute (#532 - Reuse plug window):
  call plug#begin()
  Plug 'junegunn/goyo.vim'
  call plug#end()
  PlugInstall
  call system(printf('cd "%s" && git commit --allow-empty -m "dummy"', g:plugs['goyo.vim'].dir))

  PlugDiff
  AssertEqual 1, winnr(), 'Current window is #1 after PlugDiff (but is '.winnr().')'
  AssertEqual 2, winnr('$'), 'Two windows after PlugDiff (but got '.winnr('$').')'

  " Open preview window
  execute "normal ]]jo"
  AssertEqual 2, winnr(), 'Current window is #2 after opening preview (but is '.winnr().')'
  AssertEqual 3, winnr('$'), 'Three windows with preview (but got '.winnr('$').')'

  " Move plug window to the right
  wincmd L
  AssertEqual 3, winnr(), 'Current window is #3 after moving window (but is '.winnr().')'
  AssertEqual 3, winnr('$'), 'Three windows after moving window (but got '.winnr('$').')'

  " Reuse plug window. Preview window is closed.
  PlugStatus
  AssertEqual 2, winnr(), 'Current window is #2 after PlugStatus (but is '.winnr().')'
  AssertEqual 2, winnr('$'), 'Three windows after PlugStatus (but got '.winnr('$').')'
  q

Execute (#766 - Allow cloning into an empty directory):
  let d = '/tmp/vim-plug-test/goyo-already'
  call system('rm -rf ' . d)
  call mkdir(d)
  call plug#begin()
  Plug 'junegunn/goyo.vim', { 'dir': d }
  call plug#end()
  PlugInstall
  AssertExpect! '[=]', 1
  q
  unlet d

Execute (#982 - PlugClean should report when directories cannot be removed):
  call plug#begin('$PLUG_FIXTURES')
  Plug '$PLUG_FIXTURES/ftplugin-msg', { 'for': [] }
  Plug '$PLUG_FIXTURES/fzf'
  Plug '$PLUG_FIXTURES/xxx'
  Plug '$PLUG_FIXTURES/yyy'
  call plug#end()

  " Fail to remove cant-delete
  PlugClean!
  AssertEqual 'Removed 0 directories. Failed to remove 1 directories.', getline(4)
  AssertExpect '^x ', 1
  q

  " Delete tmp but fail to remove cant-delete
  call mkdir(expand('$PLUG_FIXTURES/tmp'))
  PlugClean!
  AssertEqual 'Removed 1 directories. Failed to remove 1 directories.', getline(4)
  AssertExpect '^x ', 1
  AssertExpect '^\~ ', 1
  q
